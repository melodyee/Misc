(*let f = succ                                                               *)
(*(*let () = print_int "a" *)                                                *)
(*let range a b =                                                            *)
(*  let rec loop stk x = if x=b then List.rev stk else loop (x::stk) (x+1) in*)
(*  loop [] a                                                                *)
(*let rec show_intlist ?(sep=" ") = function                                 *)
(*  | [] -> ""                                                               *)
(*  | [x] -> string_of_int x                                                 *)
(*  | x::xs -> string_of_int x ^ sep ^ show_intlist xs                        *)
(*let show_intlist2 =                                                        *)
(*  iter (fun l -> print_endline (show_intlist l))                           *)
(*let rec show_intlist' ?(sep=" ") =                                         *)
(*     let rec loop acc = function                                           *)
(*        | [] -> fold_right (^) (rev acc) ""                                *)
(*        | x::xs -> loop ((sep^string_of_int x)::acc) xs                    *)
(*              in                                                                 *)
(*  function                                                                 *)
(*  | [] -> ""                                                               *)
(*  | [x] -> string_of_int x                                                 *)
(*  | x::xs -> loop [string_of_int x] xs                                     *)
(*                                                                           *)
(*let sum = fold_left (+) 0                                                  *)
(*(*let () = List.iter print_int (range 1 100)*)                             *)
(*(*let () = print_int (sum (range 1 1000000))*)                             *)
(*(*let () = print_string (show_intlist' (range 1 100000))*)                 *)
(*let l = map string_of_int (range 1 50000)                                  *)
(*let time f =                                                               *)
(*    let t1 = Sys.time () in                                                *)
(*      f ();                                                                  *)
(*      printf "\ntime: %f\n" (Sys.time() -. t1)                               *)
(*(*                                                                         *)
(*let () =                                                                   *)
(*  time (fun () -> print_string (fold_left (^) "" l));                      *)
(*  time (fun () -> print_string (fold_right (^) l ""))*)                    *)
(*                                                                           *)
(*let cons x y = x::y                                                        *)
(*(*let rec oneOthers l = function                                           *)
(*    | [] -> []                                                             *)
(*    | x::xs -> (x,xs):: map (fun (a,b) -> (a,x::b)) (oneOthers xs)         *)
(**)                                                                         *)
(*(*                                                                         *)
(*let rec breakings = function                                               *)
(*  | [] -> []                                                               *)
(*  | x::xs ->                                                               *)
(*      *)                                                                       *)
(*let rec permutations =                                                     *)
(*  let rec insert x = function                                              *)
(*      | [] -> [[x]]                                                          *)
(*      | (y::ys) as l -> (x::l) :: map (cons y) (insert x ys) in              *)
(*  function                                                                 *)
(*  | [] -> [[]]                                                             *)
(*  | x::xs -> concat (map (insert x) (permutations xs))                      *)
(*                                                                           *)
(*(*let () = show_intlist2 (permutations (range 1 4))*)                      *)
(*let nub l =                                                                *)
(*    let rec loop stk h = function                                          *)
(*        | [] -> List.rev stk                                               *)
(*        | x::xs -> loop (if Hashtbl.mem h x then stk else x::stk) h xs in  *)
(*    loop [] (Hashtbl.create 33) l                                          *)
(*let neib (x,y) = [x+1,y;x,y+1;x-1,y;x,y-1]                                 *)
(*                                                                           *)
(*(*let inc l =*)                                                            *)
(*                                                                           *)
(*let () = ignore (T2.cmd)                                                   *)
(*(*  ignore (Unix.system "ls")*)                                            *)
(*(*  print_int (length (nub [1;2;3;1]))*)                                   *)

(*                                                                                                    *)
(*(** 2D dense matrix*)                                                                               *)
(*module Matrix (F:Field) = struct                                                                    *)
(*  open Array                                                                                        *)
(*  open F                                                                                            *)
(*  open ExtArray                                                                                     *)
(*  type t = N.t array array                                                                          *)
(*  type vec = N.t array                                                                              *)
(*  exception WrongDimension                                                                          *)
(*  let checkDim b = if not b then raise WrongDimension                                               *)
(*  let dims ma = (length ma,length ma.(0))                                                           *)
(*  let create (m,n) = Array.make_matrix m n zero                                                     *)
(*  let row ma i = ma.(i)                                                                             *)
(*  let col ma j = init (snd (dims ma)) (fun i -> ma.(i).(j))                                         *)
(*  let dotproduct a a' = fold_left (+) zero @$ zipWith ( * ) a a'                                    *)
(*  let mult ma ma' =                                                                                 *)
(*    let (m,n) = dims ma in                                                                          *)
(*    let (m',n') = dims ma' in                                                                       *)
(*    checkDim (n=m');                                                                                *)
(*    let ma'' = create (m,n') in                                                                     *)
(*    for i =0 to m do                                                                                *)
(*      for j =0 to n' do                                                                             *)
(*        ma''.(i).(j) <- dotproduct (row ma i) (col ma' j)                                           *)
(*      done                                                                                          *)
(*    done                                                                                            *)
(*end                                                                                                 *)

(*module POLY (N:NUM) = struct                       *)
(*  open N                                           *)
(*  let add l l2 = zipWith (+) l l2                  *)
(*end                                                *)
(*module FPOLY = POLY (struct                        *)
(*  type t = float                                   *)
(*  let (+) = (+.)                                   *)
(*  end)                                             *)
(*let () = print_float @$ hd @$ FPOLY.add [1.] [2.]  *)
(*module IPOLY = POLY (struct                        *)
(*  type t = int                                     *)
(*  let (+) = (+)                                    *)
(*  end)                                             *)
(*let () = print_int @$ hd @$ IPOLY.add [1] [2]      *)

(*module M(R:R) = struct                                                                           *)
(*  open Array                                                                                     *)
(*  open ExtArray                                                                                  *)
(*  module R = Ring(R)                                                                             *)
(*  open R                                                                                         *)
(*  open MaybeMonad                                                                                *)
(*  exception WrongDimension                                                                       *)
(*  let checkDim b = if not b then raise WrongDimension                                            *)
(*  let dims ma = (length ma,length ma.(0))                                                        *)
(*  let checkSquare ma =                                                                           *)
(*    let (m,n) = dims ma in checkDim (m=n)                                                        *)
(*  let fold_col f a ma j =                                                                        *)
(*    let r = ref a in                                                                             *)
(*    for i =0 to snd (dims ma) -1 do                                                              *)
(*      r:= f i !r ma.(i).(j)                                                                      *)
(*    done;                                                                                        *)
(*    !r                                                                                           *)
(*                                                                                                 *)
(*  let findFirstColAux f ma j =                                                                   *)
(*    let n = snd (dims ma) in                                                                     *)
(*    let rec loop i =                                                                             *)
(*      if i=n then None else                                                                      *)
(*        let r = f ma.(i).(j) in                                                                  *)
(*        if isSome r then Some (fromSome r,i) else                                                *)
(*          loop (i+1) in                                                                          *)
(*    loop 0                                                                                       *)
(*  let findFirstCol f ma j = findFirstColAux f ma j >>= fun(r,_) -> return r                      *)
(*  let findIndexCol f ma j = findFirstColAux f ma j >>= fun(_,i) -> return i                      *)
(*                                                                                                 *)
(*  let dotProduct ma i ma' j =                                                                    *)
(*    fold_col (fun k a b -> add a @$ mul ma.(i).(k) b) zero ma' j                                 *)
(*  type t = R.t array array                                                                       *)
(*  let add ma ma' = zipWith (zipWith add) ma ma'                                                  *)
(*  let sub ma ma' = zipWith (zipWith sub) ma ma'                                                  *)
(*  let mult ma ma' =                                                                              *)
(*    let (m,n) = dims ma in                                                                       *)
(*    let (m',n') = dims ma' in                                                                    *)
(*    checkDim (n = m');                                                                           *)
(*    init_matrix m n' (fun i j -> dotProduct ma i ma' j)                                          *)
(*(*  let gaussianElim ma =     *)                                                                 *)
(*(*    foreachi ma @$ fun i -> *)                                                                 *)
(*(*      match findIndexCol ma *)                                                                 *)
(*                                                                                                 *)
(*(*  let inv ma =     *)                                                                          *)
(*(*    checkSquare ma;*)                                                                          *)
(*                                                                                                 *)
(*end                                                                                              *)
(*                                                                                                 *)

(*                                                                                                 *)
(*module D = Ring(struct                                                                           *)
(*    open MaybeMonad                                                                              *)
(*    type t = int option                                                                          *)
(*    let add = liftM2 (+)                                                                         *)
(*    let sub a a' = match a,a' with                                                               *)
(*      | None,_ -> None                                                                           *)
(*      | Some _,None -> Some 0                                                                    *)
(*      | Some i,Some i' -> Some (positive (i-i'))                                                 *)
(*    let mul = liftM2 ( * )                                                                       *)
(*    let div = dumb2                                                                              *)
(*    let quot = dumb2                                                                             *)
(*    let abs _ = failwith "abs"                                                                   *)
(*    let rem = dumb2                                                                              *)
(*    let show = function                                                                          *)
(*      | None -> "None"                                                                           *)
(*      | Some i -> string_of_int i                                                                *)
(*    let read = function                                                                          *)
(*      | "None" -> None                                                                           *)
(*      | x -> return @$ int_of_string x                                                           *)
(*    let compare d d' = match d, d' with                                                          *)
(*      | None, None -> 0                                                                          *)
(*      | Some _, None -> -1                                                                       *)
(*      | None, Some _ -> 1                                                                        *)
(*      | Some i, Some i' -> compare i i'                                                          *)
(*    let of_int i = return i                                                                      *)
(*  end)                                                                                           *)
(*module Dim = struct                                                                              *)
(*  include D                                                                                      *)
(*  let infinity :t = None                                                                         *)
(*  let to_int = fromSome                                                                          *)
(*(*  let trim dm = maybe 100 dm*)                                                                 *)
(*end                                                                                              *)
(*module V(R:R) = struct                                                                           *)
(*  open Array                                                                                     *)
(*  open ExtArray                                                                                  *)
(*  module R=Ring(R)                                                                               *)
(*  open R                                                                                         *)
(*  open MaybeMonad                                                                                *)
(*  type t = Dim.t * (int -> R.t)                                                                  *)
(*  exception WrongDimension                                                                       *)
(*  let checkDim b = if not b then raise WrongDimension                                            *)
(*  let dim (v:t) = fst v                                                                          *)
(*  let init n f :t  = (n,f)                                                                       *)
(*  let get (v:t) i = snd v i                                                                      *)
(*  let zipWith op (v:t) (v':t) : t =                                                              *)
(*    init (Dim.min (dim v) (dim v')) (fun i -> op (get v i) (get v' i))                           *)
(*  let to_list v =                                                                                *)
(*    let rec loop stk i =                                                                         *)
(*      if Dim.ge (Dim.of_int i) (dim v) then List.rev stk else loop (get v i::stk) (i+1) in       *)
(*    loop [] 0                                                                                    *)
(*  let of_array a :t = init (Dim.of_int (length a)) @$ fun i -> a.(i)                             *)
(*  let of_list l :t = of_array (Array.of_list l)                                                  *)
(*  let take n (v:t) :t = init (Dim.min (Dim.of_int n) (dim v)) (snd v)                            *)
(*  let drop n (v:t) :t = init (Dim.sub (dim v) (Dim.of_int n)) (snd v)                            *)
(*  let scale k v :t = init (dim v) @$ fun i -> R.mul k (get v i)                                  *)
(*  let add = zipWith add                                                                          *)
(*  let sub = zipWith sub                                                                          *)
(*  let mul = zipWith mul                                                                          *)
(*  let div a b = failwith "div"                                                                   *)
(*  let quot a b = failwith "quot"                                                                 *)
(*  let rem a b = failwith "rem"                                                                   *)
(*  let abs a = failwith "abs"                                                                     *)
(*  let compare a b = failwith "compare"                                                           *)
(*  let dot v v' = List.fold_left R.add R.zero @$ to_list @$ mul v v'                              *)
(*  let of_int i = init Dim.infinity (fun _ -> i)                                                  *)
(*  let read s = failwith "read"                                                                   *)
(*  let show v = String.concat ", " @$ List.map R.show @$ to_list (take 1000 v)                    *)
(*  let concat v v' =                                                                              *)
(*    let n = dim v in                                                                             *)
(*    let n' = dim v' in                                                                           *)
(*    init (Dim.add n n') @$ fun i ->                                                              *)
(*      if Dim.lt (Dim.of_int i) n then get v i else get v' (i - Dim.to_int n)                     *)
(*end                                                                                              *)
(*module FM(R:R) = struct                                                                          *)
(*  open Array                                                                                     *)
(*  open ExtArray                                                                                  *)
(*  module R=Ring(R)                                                                               *)
(*  open R                                                                                         *)
(*  open MaybeMonad                                                                                *)
(*  module V = V(R)                                                                                *)
(*  type t = (Dim.t* Dim.t) * (int -> int -> R.t)                                                  *)
(*                                                                                                 *)
(*  exception WrongDimension                                                                       *)
(*  let checkDim b = if not b then raise WrongDimension                                            *)
(*  let dims (ma:t) = fst ma                                                                       *)
(*  let checkSquare (ma:t) =                                                                       *)
(*    let (m,n) = dims ma in checkDim (m=n)                                                        *)
(*  let init m n f = ((m,n),f)                                                                     *)
(*  let transpose (ma:t) : t =                                                                     *)
(*    let (m,n) = dims ma in                                                                       *)
(*    init n m @$ fun j i -> snd ma i j                                                            *)
(*  let get (ma:t) i j = snd ma i j                                                                *)
(*  let row (ma:t) i : V.t = V.init (snd (dims ma)) (fun j -> get ma i j)                          *)
(*  let col (ma:t) j : V.t = V.init (fst (dims ma)) (fun i -> get ma i j)                          *)
(*  let zipWith op = zipWith (zipWith op)                                                          *)
(*  let add = zipWith add                                                                          *)
(*  let sub = zipWith sub                                                                          *)
(*  let mul (ma:t) (ma':t) :t =                                                                    *)
(*    let (m,n) = dims ma in                                                                       *)
(*    let (m',n') = dims ma' in                                                                    *)
(*    checkDim (n=m');                                                                             *)
(*    init m n' (fun i j -> V.dot (row ma i) (col ma' j))                                          *)
(*  (* select from i-th row, j-th col, note the data is shared *)                                  *)
(*  let select ma i j :t  =                                                                        *)
(*    let (m,n) = dims ma in                                                                       *)
(*    init (Dim.sub m (Dim.of_int i)) (Dim.sub n (Dim.of_int j)) @$ fun i' j' ->                   *)
(*      get ma (i'+i) (j'+j)                                                                       *)
(*  let concat ma ma' :t =                                                                         *)
(*    let (m,n) = dims ma in                                                                       *)
(*    let (m',n') = dims ma' in                                                                    *)
(*    checkDim (m=m');                                                                             *)
(*    init m (Dim.add n n') @$ fun i j -> V.get (V.concat (row ma i) (row ma' i)) j                *)
(*  let vconcat ma ma' :t = transpose @$ concat (transpose ma) (transpose ma')                     *)
(*  let hd ma = col ma 0                                                                           *)
(*  let tl ma = select ma 0 1                                                                      *)
(*  let vhd ma = row ma 0                                                                          *)
(*  let vtl ma = select ma 1 0                                                                     *)
(*  let null ma = dims ma = (Dim.zero,Dim.zero)                                                    *)
(*(*  let rec foldl f v ma =                     *)                                                *)
(*(*    if null ma then v else foldl f v (tl ma) *)                                                *)
(*(*  let guassianElim ma =*)                                                                      *)
(*                                                                                                 *)
(*end                                                                                              *)
(*                                                                                                 *)
(*                                                                                                 *)
(*let () = print_endline (Int.show @$ Int.gcd 35 20)                                               *)
(*let () = print_endline (Long.show @$ Long.gcd 35L 20L)                                           *)
(*let () = print_endline (Rational.show @$ Rational.gcd (Rational.of_int 25) (Rational.of_int 30) )*)
(*open Rational                                                                                    *)
(*let () = print_endline (show @$ average [of_int 2;of_int 3])                                     *)
(*open Float                                                                                       *)
(*let () = print_endline (show @$ average [of_int 2;of_int 3])                                     *)
(*(*let () = print_endline (show @$ pow (of_int 2) 6)*)                                            *)
(*                                                                                                 *)
(*module VInt = V(Int)                                                                             *)
(*module VIntR = Ring(VInt)                                                                        *)
(*open VIntR                                                                                       *)
(*open VInt                                                                                        *)
(*                                                                                                 *)
(*let () = print_endline (show @$ of_array [|1;2;3|])                                              *)
(*let () = print_endline (show @$ mul (of_array [|1;2;3|]) (of_array [|1;2;3|]))                   *)
(*let () = print_endline (show @$ of_list [1;2;3])                                                 *)
(*let () = print_endline (show @$ pow (of_list [1;2;3]) 4)                                         *)
(*let () = print_endline "end"                                                                     *)

(*    module type GROUP = struct                                                               *)
(*      type t                                                                                 *)
(*      val compare : t -> t -> int                                                            *)
(*      val op : t -> t -> t                                                                   *)
(*      val inv : t -> t                                                                       *)
(*      val zero : t                                                                           *)
(*    end                                                                                      *)
(*                                                                                             *)
(*    (** Persisitent *)                                                                       *)
(*    module XYProdSum (R:R) (XY:XY) = struct                                                  *)
(*      module P = XYProd(XY)                                                                  *)
(*      module R = Ring(R)                                                                     *)
(*      open HashMap                                                                           *)
(*      type t = (P.t,R.t) HashMap.t                                                           *)
(*                                                                                             *)
(*      let removeZero a =                                                                     *)
(*        let a' = create 3 in                                                                 *)
(*        iter (fun k v -> if not (R.null v) then set a' k v) a;                               *)
(*        a'                                                                                   *)
(*          let zipWith f (a:t) (a':t) =                                                       *)
(*        let a'' = create 3 in                                                                *)
(*            riter a (fun k v ->                                                              *)
(*              set a'' k (f v @$ maybe R.zero id (maybefind get a' k)));                      *)
(*        riter a' (fun k v ->                                                                 *)
(*          if not (mem a k) then set a'' k v);                                                *)
(*        removeZero a''                                                                       *)
(*                                                                                             *)
(*          let mul a a' :t =                                                                  *)
(*            let a'' = create 3 in                                                            *)
(*            (riter a @$ fun k v ->                                                           *)
(*              riter a' @$ fun k' v' ->                                                       *)
(*                let k'' = P.mul k k' in                                                      *)
(*                set a'' k'' (R.add (R.mul v v') @$ maybe R.zero id (maybefind get a'' k'')));*)
(*            removeZero a''                                                                   *)
(*      let add (a:t) (a':t) = zipWith R.add a a'                                              *)
(*      let sub (a:t) (a':t) = zipWith R.sub a a'                                              *)
(*(*      let recip a : t= riter a (fun k v -> set a (P.inv k) v);a*)                          *)
(*(*      let div a a' = mul a (recip a')                          *)                          *)
(*(*      let quot (a:t) (a':t) =*)                                                            *)
(*    end                                                                                      *)
(*                                                                                             *)
(*    module XYProdSum (R:R) (XY:XY) = struct                                                  *)
(*      module P = XYProd(XY)                                                                  *)
(*      module M =                                                                             *)
(*let trace_of_string s =                                   *)
(*  let n = String.length s in                              *)
(*  let hits = ref 0 in                                     *)
(*  let rec work last i acc =                               *)
(*    if i>=n then List.rev acc else                        *)
(*      let c = s.[i] in                                    *)
(*      if c==last then (incr hits;work last (i+1) acc) else*)
(*        work c (i+1) (int_of_char c::acc) in              *)
(*  printf "hits = %d\n" !hits;                             *)
(*  Array.of_list (work s.[0] 1 [])                         *)



(*  let hitRatio epsilon size array =                                        *)
(*    let s = ref 0. in                                                      *)
(*    let t = ref (C.create epsilon size) in                                 *)
(*    for i = 0 to Array.length array - 1 do                                 *)
(*      let t', isHit = C.accept !t array.(i) in                             *)
(*      s := !s +. isHit;                                                    *)
(*      t := t';                                                             *)
(*    done;                                                                  *)
(*    (* C.print !t; *)                                                      *)
(*    !s /. (float (Array.length array))                                     *)
(*                                                                           *)
(*  let nHitRatio n epsilon size array =                                     *)
(*    average n (fun () -> hitRatio epsilon size array)                      *)
(*                                                                           *)
(*  let hitRatioMonteCarlo epsilon size prob_array =                         *)
(*    let s = ref 0. in                                                      *)
(*    let t = ref (C.create epsilon size) in                                 *)
(*    for i = 0 to Array.length prob_array - 1 do                            *)
(*      let p, addr = prob_array.(i) in                                      *)
(*      if Random.float 1.0 <= p then begin                                  *)
(*        let t', isHit = C.accept !t addr in                                *)
(*        s := !s +. isHit;                                                  *)
(*        t := t';                                                           *)
(*      end                                                                  *)
(*    done;                                                                  *)
(*    (* C.print !t; *)                                                      *)
(*    !s /. (float (Array.length prob_array))                                *)
(*                                                                           *)
(*(* let hitRatioMonteCarloMultiLevel epsilon size_array array =           *)*)
(*(*  let prob_array = ref                                                 *)*)
(*(* (Array.map (fun e -> (0,e)) array) in for i = 0 to Array.length       *)*)
(*(* size_array -1 do hitRatioMonteCarlo epsilon size_array.(i) !prob_array*)*)
(*                                                                           *)
(*  let hitRatios = [SL.hitRatio; SPL.hitRatio;                              *)
(*    SPPL.hitRatio;                                                         *)
(*    SRR.hitRatio; SPRR.hitRatio;                                           *)
(*    SM.hitRatio;                                                           *)
(*    SM.nHitRatio 5; SM.nHitRatio 50; SM.nHitRatio 500;                     *)
(*    SPM.hitRatio; SPB.hitRatio; SAB.hitRatio; SPrB.hitRatio] in            *)
(*                                                                           *)
(*      let testHitRatio () =                                                *)
(*    let aux f =                                                            *)
(*      printf "hitRatio = %f\n" (f epsilon size trace) in                   *)
(*    List.iter aux hitRatios in                                             *)

(*module Distribution = struct                                        *)
(*  let scale = 100                                                   *)
(*  type 'a t = (int * 'a) list                                       *)
(*  let of_array arr =                                                *)
(*    let percents, es =                                              *)
(*      list_unzip (Array.to_list (Array.map                          *)
(*                (fun (a, b) -> round (a *. float scale), b) arr)) in*)
(*    list_zip (scanl (+) 0 percents) es                              *)
(*  let sample (t:'a t) =                                             *)
(*    let seed = Random.int scale in                                  *)
(*    let rec work = function                                         *)
(*      | [] -> assert false                                          *)
(*      | (pivot, e):: xs ->                                          *)
(*          if pivot > seed then e else work xs in                    *)
(*    work t                                                          *)
(*end                                                                 *)
(*                                                                    *)
(*module MarkovCompress = struct                                      *)
(*  type 'a t =  'a list * 'a Distribution.t                          *)
(*  type ('a,'b) t = ('a, 'b Distribution.t) Hashtbl.t                *)
(*  let generate t n =                                                *)
(*    let s = ref 0 in                                                *)
(*    Array.init n (fun _ ->                                          *)
(*            try s := Distribution.sample (Hashtbl.find t !s); !s    *)
(*            with Not_found -> assert false)                         *)
(*end                                                                 *)

(*module ExactCache = struct           *)
(*  module P = IntegralPolynomial      *)
(*  type t = {                         *)
(*    ratio : float;                   *)
(*    h :(address, P.t) Hashtbl.t;     *)
(*    mutable factor : P.t;            *)
(*    }                                *)
(*  let create epsilon size =          *)
(*    { ratio = 1. -. 1. /. float size;*)
(*      h = Hashtbl.create size;       *)
(*      factor = [1]}                  *)
(*  let accept' t address =            *)
(*    try Hashtbl.find t.h address     *)
(*    with Not_found ->                *)
(*      t.factor <- P.z t.factor       *)
(*  let accept = extend accept'        *)
(*  end                                *)

(*  let plot_zeta size hist =                       *)
(*    let ratio = 1. -. 1. /. float size in         *)
(*    let dist = Historgram.normalize hist in       *)
(*    let aux f = List.fold_left (+.) 0.            *)
(*        (List.map (fun (e,p) -> f e *. p) dist) in*)
(*    let s = aux (fun e -> 1. -. ratio ** e) in    *)
(*    let miu = aux (fun e -> e) in                 *)
(*    let sigma_inf = aux (fun e -> e) in           *)
(*    log s /. log ratio,                           *)
(*                                                   *)
(*type searchParam = (string , int) H.t              *)
(*type searchParamSpec = (string , int list) H.t     *)
(*	                                                 *)
(*module type SearchSpec = sig                       *)
(*(*	val refCmd : string*)                          *)
(*  val timeFilename : string                        *)
(*	val refCompileCmd : string                       *)
(*	val refOutputFilename : string                   *)
(*	val isBetter : searchParam -> searchParam -> bool*)
(*end                                                *)
(*                                                   *)
(*(*module SearchSpec = struct*)                     *)
(*(*	let refCmd = ""         *)                     *)
(*(*end                       *)                     *)
(*                                                   *)
(*                                                   *)
(*let cutoff = 0.3                                   *)
(*                                                   *)
(*let cmp = compare                                  *)
(*                                                   *)
(*let tryEach nTop l fit =                           *)
(*	take nTop @$ sortByMap cmp fit l                 *)
(*                                                   *)
(*let search n nTop s e fit =                        *)
(*	if n>=(e-s) then                                 *)
(*		tryEach nTop (range s @$ e+1) fit              *)
(*	else []                                          *)

(*        (* File calc.ml *)                                     *)
(*        let _ =                                                *)
(*          try                                                  *)
(*            let lexbuf = Lexing.from_channel stdin in          *)
(*            while true do                                      *)
(*              let result = Parser.main Lexer.token lexbuf in   *)
(*                print_int result; print_newline(); flush stdout*)
(*            done                                               *)
(*          with Lexer.Eof ->                                    *)
(*            exit 0                                             *)

(*let main =                    *)
(*	let ic = open_in "CONFIG" in*)
(*	let s = input_line ic in    *)
(*	print_endline s             *)

(*class counter = object   *)
(*	val mutable x = 0      *)
(*	method get = x         *)
(*	method inc = x <- x+1  *)
(*end                      *)
(*class counter2 = object  *)
(*	inherit counter        *)
(*	method set x' = x <- x'*)
(*end                      *)
(*let () =                 *)
(*	let c = new counter2 in*)
(*	print_int @$ c#get;    *)
(*	c#inc;                 *)
(*	print_int @$ c#get;    *)
(*	c#set 2;               *)
(*	print_int @$ c#get;    *)

(*module type Gene = sig        *)
(*	type t                      *)
(*	val crossover2 : t -> t -> t*)
(*	val mutate : float -> t -> t*)
(*	val random : t -> t         *)
(*	val show : t -> string      *)
(*end	                         *)

(*module DynArray = struct                                              *)
(*	let a = ref [||]                                                    *)
(*	let cap = ref 0                                                     *)
(*	let enlargeToAtLeast n =                                            *)
(*		let f = ref (float !cap) in                                       *)
(*		while !f <= float n do                                            *)
(*			f := !f *. 1.5 +. 1.                                            *)
(*		done;                                                             *)
(*		let n' = int_of_float !f in                                       *)
(*		Array.init n' (fun i -> if i < !cap then !a.(i) else Obj.magic 0);*)
(*		cap := n'                                                         *)
(*	let set i k =                                                       *)
(*		if i>= !cap then enlargeToAtLeast (i+1);                          *)
(*		Array.unsafe_set !a i k                                           *)
(*	let get i =                                                         *)
(*		if i>= !cap then enlargeToAtLeast (i+1);                          *)
(*		Array.unsafe_get !a i                                             *)
(*end                                                                   *)

(*class ['a] queue =                                     *)
(*	object (self)                                        *)
(*	val a = new dynArray                                 *)
(*	val cnt = new expCounter                             *)
(*	method to_array =                                    *)
(*		let i,i' = cnt#get in                              *)
(*		let a' = Array.make (1 lsl i + i') (Obj.magic 0) in*)
(*		for j = 0 to i-1 do                                *)
(*			let n = 1 lsl j in                               *)
(*			for j' = 0 to n-1 do                             *)
(*				a'.(n+j') <- (a#get j).(j')                    *)
(*			done                                             *)
(*		done;                                              *)
(*		let n = 1 lsl i in                                 *)
(*		for j' = 0 to i' -1 do                             *)
(*			a'.(n+j') <- (a#get i).(j')                      *)
(*		done;                                              *)
(*		a'                                                 *)
(*	method to_list = Array.to_list self#to_array         *)
(*	method enlarge n =                                   *)
(*		let ocap = a#cap in                                *)
(*		ignore @$ a#get n;                                 *)
(*		for i = ocap to a#cap do                           *)
(*			a#set i (Array.make (1 lsl i) (Obj.magic 0));    *)
(*		done                                               *)
(*	method push (k:'a) =                                 *)
(*		let i,i' = cnt#get in                              *)
(*		self#enlarge i;                                    *)
(*		(a#get i).(i') <- k;                               *)
(*		cnt#incr                                           *)
(*end                                                    *)
(*                                                       *)
(*let () =                                               *)
(*	let q = new queue in                                 *)
(*	q#push 2;                                            *)
(*	q#push 3;                                            *)
(*	print_intarray @$ q#to_array                         *)
	
(*                                                                *)
(*let () =                                                        *)
(*	let bl = ExtList.range 0 1000000 in                           *)
(*	let f () =                                                    *)
(*		let l = ref [] in                                           *)
(*		ignore @$ List.fold_left (fun l e -> addRefList e l;l) l bl;*)
(*		print_intlist (ExtList.take 10 !l) in                       *)
(*	let f2 () =                                                   *)
(*		let q = new queue in                                        *)
(*		ignore @$ List.fold_left (fun q e -> q#push e;q) q bl;      *)
(*		print_intlist (ExtList.take 10 (q#to_list)) in              *)
(*	printf "%f\n" @$ time f;                                      *)
(*	printf "%f\n" @$ time f2;                                     *)

(*module type Param = sig                                                                     *)
(*	val n : int                                                                               *)
(*end                                                                                         *)
(*module DigitSet (P:Param) = struct                                                          *)
(*  open Array                                                                                *)
(*  (* open ExtArray *)                                                                       *)
(*  type t = {                                                                                *)
(*    d : int array;                                                                          *)
(*    digits : int                                                                            *)
(*  }                                                                                         *)
(*  let w = Sys.word_size - 1                                                                 *)
(*  let create n' v =                                                                         *)
(*		let n = n' * P.n in                                                                     *)
(*    assert (n >= 0);                                                                        *)
(*    { d = make ((n + w - 1) / w) (if v then -1 else 0);                                     *)
(*      digits = n' }                                                                         *)
(*(*  let of_array a = { d = a; bits = w * length a }*)                                       *)
(*(*  let length bs = length bs.d*)                                                           *)
(*  let digits bs = bs.digits                                                                 *)
(*  let get bs n =                                                                            *)
(*		if ((n+P.n-1)/w) > n/w then                                                             *)
(*			let m = n/w *w +w -n in                                                               *)
(*			(Bit.getPart bs.d.(n/w) (n mod w) ((n+P.n) mod w)) lor                                *)
(*			((Bit.getPart bs.d.(n/w+1) 0 ((n+P.n) mod w)) lsl m)                                  *)
(*		else                                                                                    *)
(*			Bit.getPart bs.d.(n/w) (n mod w) ((n+P.n) mod w)                                      *)
(*	let set bs n k =                                                                          *)
(*		if ((n+P.n-1)/w) > n/w then begin                                                       *)
(*			let m = n/w *w +w -n in                                                               *)
(*			bs.d.(n/w) <- Bit.setPart bs.d.(n/w) (n mod w) ((n+P.n) mod w) k;                     *)
(*			bs.d.(n/w+1) <- Bit.setPart bs.d.(n/w+1) 0 ((n+P.n) mod w) (k lsr m)                  *)
(*		end else                                                                                *)
(*			bs.d.(n/w) <- Bit.setPart bs.d.(n/w) (n mod w) ((n+P.n) mod w) k                      *)
(*		                                                                                        *)
(*		                                                                                        *)
(*(*  let lift f = fun bs ->                                                                *)*)
(*(*		iter (fun n -> bs.d.(n / w) <- f bs.d.(n / w) (n mod w)) @$ ExtArray.range n (n+P.n)*)*)
(*(*  let set, unset, toggle = tmap3 lift (Bit.set, Bit.unset, Bit.toggle)                  *)*)
(*(*		                                                                                    *)*)
(*(*  let of_array a =                                                                      *)*)
(*(*		let n = length a in                                                                 *)*)
(*(*		let a' = create n false in                                                          *)*)
(*(*		iter (set bs(                                                                       *)*)
(*(*    { d = a' ; digits = n }                                                             *)*)
(*(*  let to_array bs = init bs.digits (get bs)                                             *)*)
(*(*                                                                                        *)*)
(*(*  let crossover2 bs bs' =                                                               *)*)
(*(*    { bs with d = init (length bs) (fun i -> Bit.crossover2 bs.d.(i) bs'.d.(i)) }       *)*)
(*(*  let copy bs = { bs with d = copy bs.d }                                               *)*)
(*(*  let random n =                                                                        *)*)
(*(*    assert (n >= 0);                                                                    *)*)
(*(*    { d = init (if n mod w = 0 then n / w else (n + w) / w) (fun i -> Random.bits ());  *)*)
(*(*      bits = n }                                                                        *)*)
(*(*  (* let iter f bs = let n = bits bs in for i = 0 to length bs-1 do let lim  *)         *)*)
(*(*  (* = min (i*w+w) n - (i*w) -1 in for j = 0 to lim do f (Bit.get bs.d.(i)   *)         *)*)
(*(*  (* j) done done                                                            *)         *)*)
(*(*  let iteri f bs =                                                                      *)*)
(*(*    let n = bits bs in                                                                  *)*)
(*(*    for i = 0 to length bs - 1 do                                                       *)*)
(*(*      let lim = min (i * w + w) n - (i * w) - 1 in                                      *)*)
(*(*      for j = 0 to lim do                                                               *)*)
(*(*        f (i * w + j) (Bit.get bs.d.(i) j)                                              *)*)
(*(*      done                                                                              *)*)
(*(*    done                                                                                *)*)
(*(*  let iter f bs = iteri (fun i -> f) bs                                                 *)*)
(*(*  let map f bs =                                                                        *)*)
(*(*    let bs' = copy bs in                                                                *)*)
(*(*    let n = bits bs in                                                                  *)*)
(*(*    for i = 0 to length bs - 1 do                                                       *)*)
(*(*      let s = ref 0 in                                                                  *)*)
(*(*      let k = ref 1 in                                                                  *)*)
(*(*      let v = ref bs.d.(i) in                                                           *)*)
(*(*      let lim = min (i * w + w) n - (i * w) - 1 in                                      *)*)
(*(*      for j = 0 to lim do                                                               *)*)
(*(*        s := !s + !k * int_of_bool (f (!v mod 2 != 0));                                 *)*)
(*(*        v := !v / 2;                                                                    *)*)
(*(*        k := !k * 2                                                                     *)*)
(*(*      done;                                                                             *)*)
(*(*      bs'.d.(i) <- !s                                                                   *)*)
(*(*    done;                                                                               *)*)
(*(*    bs'                                                                                 *)*)
(*(*  let lift2 f = fun bs bs' ->                                                           *)*)
(*(*        Array.mapi (fun i e -> f bs.d.(i) e) bs'.d, min bs.bits bs'.bits                *)*)
(*(*  let inter, union, sym_diff = tmap3 lift2 ((land), (lor), (lxor))                      *)*)
(*(*  let flip bs = map not bs                                                              *)*)
(*(*  let set bs n = bs.d.(n / w) <- Bit.set bs.d.(n / w) (n mod w)                         *)*)
(*(*  let unset bs n = bs.d.(n / w) <- Bit.unset bs.d.(n / w) (n mod w)                     *)*)
(*(*  let toggle bs n = bs.d.(n / w) <- Bit.toggle bs.d.(n / w) (n mod w)                   *)*)
(*(*  (* let crossover bss = let m,n = dims bss in init n (fun i ->              *)         *)*)
(*(*  (* bss.(Random.int m)) for i = 0 to -1 do done                             *)         *)*)
(*end                                                                                         *)
(*(*module Hex = DigitSet( *)                                                                 *)

(*module DynArray = struct                                                       *)
(*	type 'a t = {                                                                *)
(*		mutable cap : int;                                                         *)
(*		mutable d : 'a array                                                       *)
(*	}                                                                            *)
(*	let init n f = {                                                             *)
(*		cap = n;                                                                   *)
(*		d = Array.init n f                                                         *)
(*	}                                                                            *)
(*	let mapi f da = {                                                            *)
(*		da with d = Array.mapi f da.d                                              *)
(*	}                                                                            *)
(*	let iteri f da = ignore @$ mapi f da                                         *)
(*	let map f da = mapi (fun i -> f) da                                          *)
(*	let iter f da = ignore @$ map f da                                           *)
(*	                                                                             *)
(*	let enlargeToAtLeast da n =                                                  *)
(*		let f = ref (float da.cap) in                                              *)
(*		while int_of_float (!f) < n do                                             *)
(*			f := !f *. 1.5 +. 1.                                                     *)
(*		done;                                                                      *)
(*		let n' = int_of_float !f in                                                *)
(*		let ocap = da.cap in                                                       *)
(*		da.cap <- n';                                                              *)
(*		da.d <- Array.init n' (fun i -> if i < ocap then da.d.(i) else Obj.magic 0)*)
(*	let unsafe_get da i = Array.unsafe_get da.d i                                *)
(*	let unsafe_set da i v = Array.unsafe_set da.d i v                            *)
(*	                                                                             *)
(*	let get da i =                                                               *)
(*		try Array.get da.d i                                                       *)
(*		with Invalid_argument "index out of bounds" -> begin                       *)
(*					enlargeToAtLeast da (i + 1);                                         *)
(*					unsafe_get da i;                                                     *)
(*		end                                                                        *)
(*	let set da i v =                                                             *)
(*		try Array.set da.d i v                                                     *)
(*		with Invalid_argument "index out of bounds" -> begin                       *)
(*					enlargeToAtLeast da (i + 1);                                         *)
(*					unsafe_set da i v;                                                   *)
(*		end		                                                                    *)
(*end                                                                            *)

(*module DynArray = struct                                                             *)
(*	type 'a t = {                                                                      *)
(*		mutable cap : int;                                                               *)
(*		mutable d : 'a array                                                             *)
(*	}                                                                                  *)
(*	let init n f = {                                                                   *)
(*		cap = n;                                                                         *)
(*		d = Array.init n f                                                               *)
(*	}                                                                                  *)
(*	let mapi f da = {                                                                  *)
(*		da with d = Array.mapi f da.d                                                    *)
(*	}                                                                                  *)
(*	let iteri f da = ignore @$ mapi f da                                               *)
(*	let map f da = mapi (fun i -> f) da                                                *)
(*	let iter f da = ignore @$ map f da                                                 *)
(*	let unsafe_get da i = Array.unsafe_get da.d i                                      *)
(*	let unsafe_set da i v = Array.unsafe_set da.d i v                                  *)
(*	let extend da m =                                                                  *)
(*		let n' = da.cap +m in                                                            *)
(*		 	da.d <- Array.init n' (fun i -> if i < da.cap then da.d.(i) else Obj.magic 0);*)
(*			da.cap <- n'                                                                   *)
(*	let get da i = Array.get da.d i                                                    *)
(*	let set da i v =Array.set da.d i v		                                             *)
(*end                                                                                  *)
(*let () =                                                                             *)
(*	let da = DynArray.init 3 (const "a") in                                            *)
(*	printf "%s\n" @$ DynArray.get da 4                                                 *)

(*let () =                                                             *)
(*	let ds = map (Digit.ofBigInt 3) @$ map BI.of_int (range 0 10) in   *)
(*	printf "%s\n" @$ show_stringlist @$ map Digit.show @$ ds;          *)
(*	printf "%s\n" @$ show_intlist @$ map (BI.to_int*@Digit.toBigInt) ds*)

(*let proc_line i ln =                                                                                   *)
(*	match ExtString.split " " ln with                                                                    *)
(*		| [a;b;c] ->                                                                                       *)
(*			let h = HashMap.create 3 in                                                                      *)
(*			iteri (fun i c -> HashMap.set h c i) (ExtString.to_list b);                                      *)
(*			let bi = Digit.toBigInt (map (fun c -> HashMap.get h c) (ExtString.to_list a),String.length b) in*)
(*			let h' = HashMap.create 3 in                                                                     *)
(*			iteri (fun i c -> HashMap.set h' i c) (ExtString.to_list c);                                     *)
(*			let l,_ = Digit.ofBigInt (String.length c) bi in                                                 *)
(*			printf "Case #%d: %s\n" i @$ ExtString.of_list @$ map (HashMap.get h') l;                        *)
(*			flush stdout                                                                                     *)
(*		| _ -> ()                                                                                          *)
(*                                                                                                       *)
(*open ExtString                                                                                         *)
(*                                                                                                       *)
(*let () =                                                                                               *)
(*	ACM.process "/home/zsc/tmpd/A-small-practice.in" proc_line                                           *)

(*module Dlist = struct                                                                                *)
(*  let bind m k = match m with                                                                        *)
(*      None -> None                                                                                   *)
(*    | Some x -> k x                                                                                  *)
(*  let (>>=) = bind                                                                                   *)
(*                                                                                                     *)
(*	type 'a t = Nil | Node of 'a t * 'a * 'a t                                                         *)
(*	let rec cons d t = match t with                                                                    *)
(*		| Nil -> Node(Nil,d,Nil)                                                                         *)
(*		| Node(p,d',s) ->                                                                                *)
(*			let rec x = Node(p,d,x')                                                                       *)
(*			and x' = Node(x,d',s) in                                                                       *)
(*			x                                                                                              *)
(*	let shift = function                                                                               *)
(*		| Nil                                                                                            *)
(*		| Node(_,_,Nil) -> None                                                                          *)
(*		| Node (_,_,Node(p,d,s)) as x -> Some (Node(x,d,s))                                              *)
(*	let rev_shift = function                                                                           *)
(*		| Nil -> None                               (*						&& (n=0 ||                                                *)
(*						(Dlist.cur dl' >>= fun cur ->                             *)
(*							Dlist.rest dl' >>= fun rest ->                          *)
(*						Some (Dlist.equal (Dlist.cons cur rest) dl')) = Some true)*)                                                     *)
(*		| Node(Nil,_,_) -> None                     (*						&& (n=0 ||                                                *)
(*						(Dlist.cur dl' >>= fun cur ->                             *)
(*							Dlist.rest dl' >>= fun rest ->                          *)
(*						Some (Dlist.equal (Dlist.cons cur rest) dl')) = Some true)*)                                                     *)
(*		| Node(Node(p,d,s),_,_) as x -> Some (Node(p,d,x))                                               *)
(*	let cur = function                                                                                 *)
(*		| Nil -> None                                                                                    *)
(*		| Node(_,d,_) -> Some d                                                                          *)
(*	let rec hd = function                                                                              *)
(*		| Nil -> None                                                                                    *)
(*		| Node (Nil,d,_) -> d                                                                            *)
(*		| Node (p,d,_) -> hd p                                                                           *)
(*	let rec tl = function                                                                              *)
(*		| Nil -> None                                                                                    *)
(*		| Node (p,d,s) -> Some begin                                                                     *)
(*				match tl p with                                                                              *)
(*					| None -> s                                                                                *)
(*					| Some p' -> Node (p',d,s)                                                                 *)
(*			end Dlist.to_list @$ fromSome (Dlist.rest (fromSome @$ Dlist.shift @$ Dlist.of_list [1;2;3]));;*)
(*	let rec normalize n = match n with                                                                 *)
(*		| Nil                                                                                            *)
(*		| Node(Nil,_,_) -> n                                                                             *)
(*		| Node(Node(p,d,_),_,_) as x -> normalize (Node(p,d,x))                                          *)
(*	let rec rev_normalize n =match n with                                                              *)
(*		| Nil                                                                                            *)
(*		| Node(_,_,Nil) -> n                                                                             *)
(*		| Node(_,_,Node(_,d,s)) as x -> rev_normalize (Node(x,d,s))                                      *)
(*	let append t t' = match rev_normalize t, normalize t' with                                         *)
(*		| Nil,_ -> t'                                                                                    *)
(*		| _,Nil -> t                                                                                     *)
(*		| Node(p,d,Nil),Node(_,d',s') ->                                                                 *)
(*			let rec x = Node(p,d,x')                                                                       *)
(*			and x' = Node(x,d',s') in                                                                      *)
(*			x                                                                                              *)
(*		| _ -> assert false                                                                              *)
(*	let rest = function                                                                                *)
(*		| Nil -> None                                                                                    *)
(*		| Node(p'',d'',s'') -> Some begin match p'',s'' with                                             *)
(*			| Nil,Nil -> Nil                                                                               *)
(*			| Nil,Node(_,d,s) -> Node(Nil,d,s)                                                             *)
(*			| Node(p,d,_),Nil -> Node(p,d,Nil)                                                             *)
(*			| Node(p,d,s),Node(p',d',s') ->                                                                *)
(*				let rec x = Node(p,d,x')                                                                     *)
(*				and x' = Node(x,d',s') in                                                                    *)
(*				x                                                                                            *)
(*			end                                                                                            *)
(*                                                                                                     *)
(*	let rec of_list = function                                                                         *)
(*		| [] -> Nil                                                                                      *)
(*		| x::xs -> cons x (of_list xs)                                                                   *)
(*                                                                                                     *)
(*	let pre t = rev_shift t >>= cur                                                                    *)
(*	let post t = shift t >>= cur                                                                       *)
(*	let to_list t =                                                                                    *)
(*		let rec work = function                                                                          *)
(*			| Nil -> []                                                                                    *)
(*			| Node(_,d,s) -> d::work s in                                                                  *)
(*		work (normalize t)                                                                               *)
(*	let print show t =                                                                                 *)
(*		List.iter (fun e -> printf "%s," (show e)) (to_list t)                                           *)
(*		                                                                                                 *)
(*	let rev t = of_list@$List.rev@$to_list t                                                           *)
(*	let length t = List.length (to_list t)                                                             *)
(*	let equal t t' =                                                                                   *)
(*		let rec work t t' = match t,t' with                                                              *)
(*			| Nil,Nil -> true                                                                              *)
(*			| Nil,_                                                                                        *)
(*			| _,Nil -> false                                                                               *)
(*			| Node(_,d,s),Node(_,d',s') -> d=d' && work s s' in                                            *)
(*		work (normalize t) (normalize t')                                                                *)
(*end                                                                                                  *)

(*module Dag                                                      *)
(*(*: sig                                        *)               *)
(*(*	type 'a t                                  *)               *)
(*(*	val cons : 'a -> 'a t -> 'a t              *)               *)
(*(*	val show : ('a -> string) -> 'a t -> string*)               *)
(*(*	end                                        *)               *)
(*	= struct                                                      *)
(*	type 'a t = 'a rdag list                                      *)
(*	and 'a rdag = Node of 'a rdag ref list * 'a * 'a rdag ref list*)
(*	let singleton d = Node([],d,[])                               *)
(*	let prepend n (Node(p,d,s)) = Node(n::p,d,s)                  *)
(*	let consR d (Node(p,d',s)) =                                  *)
(*		let n = ref (singleton d) in                                *)
(*		let x' = Node(n::p,d',s) in                                 *)
(*		n := Node([],d,[ref x']);                                   *)
(*		!n                                                          *)
(*	let cons d = function                                         *)
(*		| [] -> [Node([],d,[])]                                     *)
(*		| x::xs -> consR d x::xs                                    *)
(*                                                                *)
(*  let roots t = map (fun (Node(p,d,s)) -> d) t                  *)
(*	let mergeBy f t =                                             *)
(*		let d = f @$ roots t in                                     *)
(*		let n = ref (singleton d) in                                *)
(*		n := Node([],d,map (ref*@prepend n) t);                     *)
(*		[!n]                                                        *)
(*	let rec showR showE (Node(p,d,s)) =                           *)
(*		show_stringlist [showE d;                                   *)
(*		show showE @$ map (!) p;                                    *)
(*		show showE @$ map (!) s;]                                   *)
(*	and show showE = show_stringlist *@ map (showR showE)         *)
(*	                                                              *)
(*	let rec ofTree = function                                     *)
(*		| Tree.Leaf -> []                                           *)
(*		| Tree.Branch(e,l) -> [Node([],e,map ref @$ ofForest l)]    *)
(*	and ofForest t = concatMap ofTree t                           *)
(*end                                                             *)
(*                                                                *)
(*module Dag2 = struct                                            *)
(*	open List                                                     *)
(*	type 'a t = 'a rdag list                                      *)
(*	and 'a rdag = {                                               *)
(*			mutable preds : 'a t;                                     *)
(*			d : 'a;                                                   *)
(*			mutable succs : 'a t                                      *)
(*		}                                                           *)
(*	let singletonR d = { preds = [] ; d = d ; succs = [] }        *)
(*	let consR d rt =                                              *)
(*		let rec x = { preds = [] ; d = d ; succs = [x'] }           *)
(*		and x' = { rt with preds = x::rt.preds} in                  *)
(*		x                                                           *)
(*	let empty = []                                                *)
(*	let cons d = function                                         *)
(*		| [] -> [singletonR d]                                      *)
(*		| x::xs -> consR d x::xs                                    *)
(*	let rec headsR rt = match rt.preds with                       *)
(*		| [] -> [rt.d]                                              *)
(*		| x -> heads x                                              *)
(*	and heads t = concatMap headsR t                              *)
(*	let curR rt = rt.d                                            *)
(*	let curs t = map curR t                                       *)
(*	let mergeAll f t =                                            *)
(*		let x = { preds = [] ; d = f (curs t); succs = t} in        *)
(*		iter (fun rt -> rt.preds <- x :: rt.preds) t;               *)
(*		t                                                           *)
(*	let mergeBy f filter t =                                      *)
(*		let l',l'' = partition filter t in                          *)
(*		mergeAll f l' @ l''                                         *)
(*                                                                *)
(*(*	let show =           *)                                     *)
(*(*		show_stringlist @$ *)                                     *)
(*end                                                             *)

(*module Mips = struct                                                                          *)
(*  type reg = int                                                                              *)
(*  type immed = int                                                                            *)
(*  type addr = immed * reg                                                                     *)
(*  type cmpOp =                                                                                *)
(*    [ `EQ | `NE | `LE | `LT | `GE | `GT]                                                      *)
(*  let pCmpOp = function                                                                       *)
(*    | "eq" -> `EQ                                                                             *)
(*    | "ne" -> `NE                                                                             *)
(*    | "le" -> `LE                                                                             *)
(*    | "lt" -> `LT                                                                             *)
(*    | "ge" -> `GE                                                                             *)
(*    | "gt" -> `GT                                                                             *)
(*    | _ -> failwith "pCmpOp"                                                                  *)
(*  let showCmpOp = function                                                                    *)
(*    | `EQ -> "eq"                                                                             *)
(*    | `NE -> "ne"                                                                             *)
(*    | `LE -> "le"                                                                             *)
(*    | `LT -> "lt"                                                                             *)
(*    | `GE -> "ge"                                                                             *)
(*    | `GT -> "gt"                                                                             *)
(*  type ternop =                                                                               *)
(*    [ `And | `Or | `Xor | `Nor                                                                *)
(*    | `Slt                                                                                    *)
(*    | `Add | `Sub                                                                             *)
(*    | `Mulg | `Divg | `Modg                                                                   *)
(*    | `Sll | `Srl | `Sra                                                                      *)
(*    | `B of cmpOp | `Bz of cmpOp                                                              *)
(*    ]                                                                                         *)
(*  let pTernOp = function                                                                      *)
(*    | "and" -> `And                                                                           *)
(*    | "or" -> `Or                                                                             *)
(*    | "xor" -> `Xor                                                                           *)
(*    | "nor" -> `Nor                                                                           *)
(*    | "slt" -> `Slt                                                                           *)
(*    | "add" -> `Add                                                                           *)
(*    | "sub" -> `Sub                                                                           *)
(*    | "mult" -> `Mulg                                                                         *)
(*    | "div" -> `Divg                                                                          *)
(*    | "mod" -> `Modg                                                                          *)
(*    | "sll" -> `Sll                                                                           *)
(*    | "sra" -> `Sra                                                                           *)
(*    | "srl" -> `Srl                                                                           *)
(*    | _ -> failwith "pTernOp"                                                                 *)
(*  let showTernOp = function                                                                   *)
(*    | `And -> "and"                                                                           *)
(*    | `Or -> "or"                                                                             *)
(*    | `Xor -> "xor"                                                                           *)
(*    | `Nor -> "nor"                                                                           *)
(*    | `Slt -> "slt"                                                                           *)
(*    | `Add -> "add"                                                                           *)
(*    | `Sub -> "sub"                                                                           *)
(*    | `Mulg -> "mult"                                                                         *)
(*    | `Divg -> "div"                                                                          *)
(*    | `Modg -> "mod"                                                                          *)
(*    | `Sll -> "sll"                                                                           *)
(*    | `Sra -> "sra"                                                                           *)
(*    | `Srl -> "srl"                                                                           *)
(*    | `B c -> "b" ^ showCmpOp c                                                               *)
(*    | `Bz c -> "b" ^ showCmpOp c ^ "z"                                                        *)
(*  type binop =                                                                                *)
(*    [ `Mul | `Div                                                                             *)
(*    | `Lui                                                                                    *)
(*    | `Mfc0 | `Mtc0                                                                           *)
(*    ]                                                                                         *)
(*  let pBinop = function                                                                       *)
(*    | "mult" -> `Mul                                                                          *)
(*    | "div" -> `Div                                                                           *)
(*    | "mfc0" -> `Mfc0                                                                         *)
(*    | "mtc0" -> `Mtc0                                                                         *)
(*    | _ -> failwith "pBinop"                                                                  *)
(*  let showBinop = function                                                                    *)
(*    | `Mul -> "mult"                                                                          *)
(*    | `Div -> "div"                                                                           *)
(*    | `Mfc0 -> "mfc0"                                                                         *)
(*    | `Mtc0 -> "mtc0"                                                                         *)
(*  type uop =                                                                                  *)
(*    [ `Sqrt                                                                                   *)
(*    | `J                                                                                      *)
(*    | `Mflo |`Mfhi | `Mtlo | `Mthi                                                            *)
(*    | `Bc1t | `Bc1f                                                                           *)
(*    ]                                                                                         *)
(*  let pUop = function                                                                         *)
(*    | "sqrt" -> `Sqrt                                                                         *)
(*    | "j" -> `J                                                                               *)
(*    | "mflo" -> `Mflo                                                                         *)
(*    | "mfhi" -> `Mfhi                                                                         *)
(*    | "mtlo" -> `Mtlo                                                                         *)
(*    | "mthi" -> `Mthi                                                                         *)
(*    | "bc1t" -> `Bc1t                                                                         *)
(*    | "bc1f" -> `Bc1f                                                                         *)
(*    | _ -> failwith "pUop"                                                                    *)
(*  type modifier =                                                                             *)
(*    [ `FD | `FS | `PS                                                                         *)
(*    | `B | `H | `W | `D                                                                       *)
(*    | `U                                                                                      *)
(*    | `L | `R                                                                                 *)
(*    | `AL                                                                                     *)
(*    | `G                                                                                      *)
(*    | `V | `S32                                                                               *)
(*    ]                                                                                         *)
(*  let pMod = function                                                                         *)
(*    | 'b' -> [`B]                                                                             *)
(*    | 'h' -> [`H]                                                                             *)
(*    | 'w' -> [`W]                                                                             *)
(*    | 'd' -> [`D]                                                                             *)
(*    | 'l' -> [`L]                                                                             *)
(*    | 'r' -> [`R]                                                                             *)
(*    | 'g' -> [`G]                                                                             *)
(*    | _ -> []                                                                                 *)
(*  let showMod = function                                                                      *)
(*    | `B -> "b"                                                                               *)
(*    | `H -> "h"                                                                               *)
(*    | `W -> "w"                                                                               *)
(*    | `D -> "d"                                                                               *)
(*    | `L -> "l"                                                                               *)
(*    | `R -> "r"                                                                               *)
(*    | `G -> "g"                                                                               *)
(*    | `AL -> "al"                                                                             *)
(*    | `FD -> ".d"                                                                             *)
(*    | `FS -> ".s"                                                                             *)
(*  type instr =                                                                                *)
(*    [ `Load of (reg * addr)                                                                   *)
(*    | `Store of (reg * addr)                                                                  *)
(*    | `TOp of (ternop * reg * reg * reg)                                                      *)
(*    | `TOpI of (ternop * reg * reg * immed)                                                   *)
(*    | `BOp of (binop * reg * reg)                                                             *)
(*    | `BOpI of (binop * reg * immed)                                                          *)
(*    | `UOp of (uop * reg)                                                                     *)
(*    | `UOpI of (uop * immed)                                                                  *)
(*    | `Attr of (modifier list * instr)                                                        *)
(*    ]                                                                                         *)
(*  let showReg ?(float=false) i =                                                              *)
(*    (if float then "$f" else "$" ) ^ string_of_int i                                          *)
(*  let showAddr (i,r) = sprintf "%d($%d)" i r                                                  *)
(*  let showImmed = string_of_int                                                               *)
(*  let showModsLoadStore l = String.concat "" (map showMod l)                                  *)
(*  let showModsOp l show t =                                                                   *)
(*    let pre,l' =                                                                              *)
(*      match pick (function `D -> Some `D | _ -> None) l with                                  *)
(*        | None -> "",l                                                                        *)
(*        | Some (_,l') -> "d",l'                                                               *)
(*    in                                                                                        *)
(*    pre ^ show t ^ String.concat "" (map showMod l')                                          *)
(*  let showInstr ?(float=false) = function                                                     *)
(*    | `Attr (l,`Load(r,a)) ->                                                                 *)
(*      sprintf "l%s %s,%s" (showModsLoadStore l) (showReg r) (showAddr a)                      *)
(*    | `Attr (l,`Store(r,a)) ->                                                                *)
(*      sprintf "s%s %s,%s" (showModsLoadStore l) (showReg r) (showAddr a)                      *)
(*    | `Attr (l,`TOp(t,r,r',r'')) ->                                                           *)
(*      sprintf "%s %s,%s,%s" (showModsOp l showTernOp t) (showReg r) (showReg r') (showReg r'')*)
(*    | `Attr (l,`TOpI(t,r,r',i)) ->                                                            *)
(*      sprintf "%s %s,%s,%s" (showTernOp t)                                                    *)
(*        (String.concat "" (map showMod l)) (showReg r) (showReg r') (showImmed i)             *)
(*    | `Attr (l,`BOp(t,r,r')) ->                                                               *)
(*      sprintf "%s%s %s,%s" (showTernOp t)                                                     *)
(*        (String.concat "" (map showMod l)) (showReg r) (showReg r')                           *)
(*    | `Attr (l,`BOpI(t,r,r')) ->                                                              *)
(*      sprintf "%s%s %s,%s" (showTernOp t)                                                     *)
(*        (String.concat "" (map showMod l)) (showReg r) (showReg r')                           *)
(*                                                                                              *)
(*                                                                                              *)
(*end                                                                                           *)

(*          match r with                                                                                      *)
(*          | Left l -> printf "Left %s\n" @$ show_stringlist l                                               *)
(*          | Right(t, rest) -> begin                                                                         *)
(*                match begin match List.map List.hd (List.filter (not *@ExtList.null) t) with                *)
(*                  | [x] -> Mips.parse0 x                                                                    *)
(*                  | [x; r] -> Mips.parse1 (x, int_of_string r)                                              *)
(*                  | [x; r; r'] ->                                                                           *)
(*                      Mips.parse2 (x, int_of_string r, int_of_string r')                                    *)
(*                  | [x; r; r'; r''] -> Mips.parse3 (x, int_of_string r, int_of_string r', int_of_string r'')*)
(*                  | _ -> None                                                                               *)
(*                end with                                                                                    *)
(*                | Some instr -> printf "%s\n" (Mips.showInstr instr)                                        *)
(*                | None -> printf "error\n"                                                                  *)
(*              end                                                                                           *)
      (* List.iter (printf "Right %s\n" *@ show_stringlist) t; printf "%s\n" @$  *)
      (* show_stringlist rest                                                    *)
(*    <|> pThen4 (curry4 Mips.parseTOpI)                                 *)
(*        pInstr pReg (P.bind (pLit ",") pReg) (P.bind (pLit ",") pImmed)*)
(*          <|> sequence [pInstr; pReg; P.bind (pLit ",") pReg]                                             *)
(*          <|> sequence [pInstr; pReg; P.bind (pLit ",") pImmed; P.bind (pLit "(") pReg; P.drop (pLit ")")]*)

(*module InstrLexer = struct                                                       *)
(*  open ExtChar                                                                   *)
(*  open ExtString                                                                 *)
(*  type token = string                                                            *)
(*  let tokenize s =                                                               *)
(*    let keywords = ['$';'(';')';',';'-'] in                                      *)
(*    let rec work acc l =                                                         *)
(*      match l with                                                               *)
(*      | [] -> List.rev acc                                                       *)
(*      | x:: xs ->                                                                *)
(*          if x = '-' || isDigit x then                                           *)
(*            let i, l' = lexDigit l in work (string_of_int i:: acc) l'            *)
(*          else if List.mem x keywords then work (String.make 1 x:: acc) xs       *)
(*          else if List.mem x [' ';'\t'] then work acc xs                         *)
(*          else let s, l' = span (Logic.either isAlpha ((=) '.')) l in            *)
(*            work (of_list s:: acc) l'                                            *)
(*                                                                                 *)
(*    and lexDigit ?(sym = 1) = function                                           *)
(*      | [] -> 0,[]                                                               *)
(*      | '-':: xs -> lexDigit ~sym: (- 1) xs                                      *)
(*      | l -> let l', l'' = span isDigit l in                                     *)
(*          sym * (IntList.parse_integral *@ List.map ExtChar.parse_int) l', l'' in*)
(*    work [] (to_list s)                                                          *)
(*end                                                                              *)

(*  let tokenize s =                                                                   *)
(*    let keywords = ['$';'(';')';',';'-';'%'] in                                      *)
(*    let rec work acc l =                                                             *)
(*      match l with                                                                   *)
(*      | [] -> List.rev acc                                                           *)
(*      | x:: xs ->                                                                    *)
(*          if isDigit x then                                                          *)
(*            let l', l'' = span isDigit l in                                          *)
(*            let i = (IntList.formInt *@ List.map ExtChar.digitToInt) l' in           *)
(*            work (string_of_int i:: acc) l''                                         *)
(*          else if List.mem x keywords then work (String.make 1 x:: acc) xs           *)
(*          else if List.mem x [' ';'\t'] then work acc xs                             *)
(*          else let s, l' = span (Logic.either isAlpha (flip List.mem ['.';'_'])) l in*)
(*            work (of_list s:: acc) l'                                                *)
(*    in                                                                               *)
(*    work [] (to_list s)                                                              *)

(*let preprocess s =                                                *)
(*  ExtString.replace                                               *)
(*    (ExtString.replace                                            *)
(*        (ExtString.replace s "$gp" "$28") "$sp" "$29") "$ra" "$31"*)
(*                                                                  *)

(*module Function = struct     *)
(*  let lift2 g f f' = fun x ->*)
(*        let i = f x in       *)
(*        g i (f' x)           *)
(*end                          *)

(*module MIPS = struct                                   *)
(*    type reg = int                                     *)
(*    type freg = int                                    *)
(*    type immed = int                                   *)
(*    type addr = immed * reg                            *)
(*                                                       *)
(*    type binop =                                       *)
(*        | And                                          *)
(*        | Or                                           *)
(*        | Xor                                          *)
(*        | Nor                                          *)
(*        | Slt                                          *)
(*        | Add                                          *)
(*        | Sub                                          *)
(*        | Mulg                                         *)
(*        | Divg                                         *)
(*        | Modg                                         *)
(*        | FAdd                                         *)
(*        | FSub                                         *)
(*        | FMul                                         *)
(*        | FDiv                                         *)
(*        | Sll                                          *)
(*        | Srl                                          *)
(*        | Sra                                          *)
(*    type uop =                                         *)
(*        | Sqrt                                         *)
(*    type modifier =                                    *)
(*        | B     | H     | W     | D                    *)
(*        | U                                            *)
(*        | L     | R                                    *)
(*        | AL                                           *)
(*        | Z                                            *)
(*                                                       *)
(*    type cmpOp =                                       *)
(*        | EQ                                           *)
(*        | NE                                           *)
(*        | LE                                           *)
(*        | LT                                           *)
(*        | GE                                           *)
(*        | GT                                           *)
(*                                                       *)
(*    type instr =                                       *)
(*        | Load of reg * addr * modifier list           *)
(*        | FLoad of freg * addr * modifier list         *)
(*        | Store of reg * addr * modifier list          *)
(*        | FStore of freg * addr * modifier list        *)
(*        | Comp of reg * reg * reg * modifier list      *)
(*        | CompI of reg * reg * immed * modifier list   *)
(*        | Jr of reg * modifier list                    *)
(*        | J of immed * modifier list                   *)
(*        | Lui of reg * immed                           *)
(*        | Mflo of reg                                  *)
(*        | Mtlo of reg                                  *)
(*        | Mfhi of reg                                  *)
(*        | Mthi of reg                                  *)
(*        | Mul of reg * reg * modifier list             *)
(*        | Div of reg * reg * modifier list             *)
(*        | B of cmpOp * modifier list                   *)
(*        | Bc1t of immed * modifier list                *)
(*        | Bc1f of immed * modifier list                *)
(*                                                       *)
(*                                                       *)
(*    let countChar c s =                                *)
(*        length @$ filter ((=) c) @$ ExtString.to_list s*)
(*                                                       *)
(*(*  let of_string s =           *)                     *)
(*(*      match countChar '$' s with*)                   *)
(*(*          | 0 -> begin            *)                 *)
(*(*                                    *)               *)
(*(*              end                   *)               *)
(*(*          | 1 -> begin            *)                 *)
(*(*              end                   *)               *)
(*(*          | 2 -> begin            *)                 *)
(*(*              end                   *)               *)
(*(*          | 3 -> begin            *)                 *)
(*(*              end                   *)               *)
(*end                                                    *)

(*module Dag = struct                                                                   *)
(*  open List                                                                           *)
(*  type 'a t = { nodes : 'a array ; succs : int -> int list ; preds : int -> int list }*)
(*  type 'a node = { content : 'a ; preds : 'a t ; succs : 'a t}                        *)
(*  and 'a t = 'a node list                                                             *)
(*  let succs n = n.succs                                                               *)
(*  let preds n = n.preds                                                               *)
(*  let ofOrderAndList orders l =                                                       *)
(*    let h = Hashtbl.create 3 in                                                       *)
(*    let h' = Hashtbl.create 3 in                                                      *)
(*    iter (fun (a,b) -> Hashtbl.add h a b;Hashtbl.add h' b a) orders;                  *)
(*    map (fun a -> {                                                                   *)
(*      content = a;                                                                    *)
(*      preds = Hashtbl.find_all h' a;                                                  *)
(*      succs = Hashtbl.find_all h a}) l                                                *)
(*end                                                                                   *)

(*        (printf "%s\n" *@ show) f*)
(*          MipsAsmParser.mapOverBBs (map (fun s -> printf ">%s\n" s;flush stdout;s)) @$*)
(*          MipsAsmParser.mapOverFuns (MipsAsmParser.Function.mapOverBBs (map (fun s -> printf ">%s\n" s;flush stdout;s))) @$*)
                
(*            Sys.argv.(1)*)
(*        "../parser/tests/fib.s"*)
(*        "../parser/tests/t.s"*)
(*   printf "%s\n" @$ show_listlist @$ isolate (token "# Program Unit:") (fun s -> ) @$ *)
(*      ExtUnix.readAllFile "/home/zsc/tmpd/t.s"                                          *)

(*module Int              *)
(*:sig                    *)
(*  type t = int          *)
(*  val id : t -> t       *)
(*  end                   *)
(* = struct               *)
(*  type t = int          *)
(*  let id t = t          *)
(*  end                   *)
(*                        *)
(*let () =                *)
(*  print_int @$  Int.id 3*)

(*module StreamMonad = struct                 *)
(*  type 'a stream =                          *)
(*    | Nil                                   *)
(*    | Cons of 'a * ('a stream) Lazy.t       *)
(*  type 'a t = ('a stream) Lazy.t            *)
(*  let empty = lazy Nil                      *)
(*  let cons e t = lazy (Cons (e,t))          *)
(*  let null t = Lazy.force t = Nil           *)
(*  let headTail t = match Lazy.force t with  *)
(*    | Nil -> failwith "hd"                  *)
(*    | Cons (e,l) -> e,l                     *)
(*  let head t = fst @$ headTail t            *)
(*  let tail t = snd @$ headTail t            *)
(*  let rec takeDrop n t =                    *)
(*    if n<=0 then empty,t else               *)
(*      if null t then empty,empty else       *)
(*      let x,xs = headTail t in              *)
(*      let l,l' = takeDrop (n-1) xs in       *)
(*      cons x l,l'                           *)
(*  let take n t = fst (takeDrop n t)         *)
(*  let drop n t = snd (takeDrop n t)         *)
(*  let rec toList t = match Lazy.force t with*)
(*    | Nil -> []                             *)
(*    | Cons (e,l) -> e :: toList l           *)
(*  let rec ofList = function                 *)
(*    | [] -> empty                           *)
(*    | x::xs -> cons x (ofList xs)           *)
(*  let rec prepend l t =                     *)
(*    List.fold_right cons l t                *)
(*  let rec cycle l =                         *)
(*    prepend l (lazy (Lazy.force (cycle l))) *)
(*  let repeat e = cycle [e]                  *)
(*                                            *)
(*  end                                       *)

(*let () =                                                                          *)
(*  print_endline @$ show_intlist @$ StreamMonad.take 30 (StreamMonad.cycle [1;2;3])*)
 
(*open PartialOrder*)
(*let () =                                                                                                                             *)
(*(*  print_endline @$ show_intlist @$ StreamMonad.take 10 @$ StreamMonad.filter (fun k -> k mod 2 =0) @$ StreamMonad.enum 0 1*)       *)
(*  print_endline @$ show_listlist string_of_int @$ StreamMonad.take 10 @$ legalPermutations (of_list [2, 1; 1, 3; 3, 4]) (range 0 100)*)
(*(*  print_endline @$ show_list show_intlist @$ take 10 @$ legalPermutations (of_list [2, 1; 1, 3; 3, 4]) (range 0 100)*)             *)

(*open MaybeMonad                                                                                         *)
(*let () =                                                                                                *)
(*  (match PartialOrder.TransitiveClosure.ofPartialOrder (PartialOrder.of_list [2, 1; 1, 3; 3, 4]) with   *)
(*    | Some t -> printf "tc:%s\n" @$ PartialOrder.TransitiveClosure.show t                               *)
(*    | None -> ()                                                                                        *)
(*  );                                                                                                    *)
(*  (match PartialOrder.topoSort (PartialOrder.of_list [2, 1; 1, 3]) (range 0 4) with                     *)
(*    | Some l -> printf "topo:%s\n" @$ show_intlist l                                                    *)
(*    | None -> ()                                                                                        *)
(*  );                                                                                                    *)
(*(*  Random.self_init ();*)                                                                              *)
(*    (match                                                                                              *)
(*        PartialOrder.TransitiveClosure.ofPartialOrder @$ PartialOrder.of_list [2, 1; 1, 3] >>= fun t -> *)
(*            PartialOrder.random t (range 0 4) with                                                      *)
(*    | Some l -> printf "random:%s\n" @$ show_intlist l                                                  *)
(*    | None -> ()                                                                                        *)
(*  )                                                                                                     *)
(*                                                                                                        *)
(*let () =                                                                                                *)
(*  printf "%s\n" @$ show_listlist string_of_int @$                                                       *)
(*  PartialOrder.legalPermutations (PartialOrder.of_list [2, 1; 1, 3]) (range 0 4)                        *)

(*module FunMonad = struct                           *)
(*    type 'a t = unit -> 'a                         *)
(*    let return x = fun () -> x                     *)
(*    let bind m k = fun () -> k (m ()) ()           *)
(*    let (>>=) = bind                               *)
(*(*  let foldl f i l =                   *)         *)
(*(*      let rec work i = function         *)       *)
(*(*          | [] -> return i                *)     *)
(*(*          | x::xs ->                      *)     *)
(*(*              return x >>= fun x ->         *)   *)
(*(*                  return (f i x) >>= fun i' ->*) *)
(*(*                  work i' xs in             *)   *)
(*(*    (work i l) ()                     *)         *)
(*(*  let foldl1 f = function             *)         *)
(*(*      | [] -> failwith "foldl1"         *)       *)
(*(*      | x::xs -> foldl f x xs           *)       *)
(*                                                   *)
(*(*  open LazyList                        *)        *)
(*(*  let foldl f i l =                    *)        *)
(*(*      let rec work i s =                 *)      *)
(*(*          if null s then return i else     *)    *)
(*(*              let x,xs = headTail s in       *)  *)
(*(*              (fun () -> f i x) >>= fun i' ->*)  *)
(*(*                  work i' xs in                *)*)
(*(*      (work i l) ()                      *)      *)
(*(*  let foldl1 f s =                     *)        *)
(*(*      let x,xs = headTail s in           *)      *)
(*(*      foldl f x xs                       *)      *)
(*    end                                            *)

(*  open LazyList                                                       *)
(*  let mapi f s =                                                      *)
(*    zipWith                                                           *)
(*  let alignBy eq l l' =                                               *)
(*(*    let merge s s' =                                              *)*)
(*(*      if null s then s' else                                      *)*)
(*(*        if null s' then s else                                    *)*)
(*(*          let x,xs = headTail s in                                *)*)
(*(*          let y,ys = headTail s' in                               *)*)
(*(*          if fst x <= fst y then cons x (fun () -> InC(merge xs ))*)*)
(*      let rec work score l l' = match l,l' with                         *)
(*        | [],[] -> empty                                                *)
(*        | [],l' -> mapi (fun i e -> -i,right e) (of_list l')            *)
(*      | l,[] -> mapi left (of_list l)                                 *)
(*      | x::xs,y::ys ->                                                *)
(*        if eq x y then cons (same x) (work xs ys) else                *)
(*          merge (work (score-1) xs l')  (work (score-1) l ys) in      *)
(*    work 0 l l'                                                       *)

(*  module Variable = struct                                                                  *)
(*    open Parray                                                                             *)
(*    exception Found of int                                                                  *)
(*    type address = int                                                                      *)
(*    type variable = address                                                                 *)
(*    type heap = variable option array                                                       *)
(*    let create heap () =                                                                    *)
(*      try                                                                                   *)
(*        for i=0 to Array.length heap-1 do                                                   *)
(*          match heap.(i) with                                                               *)
(*            | None ->                                                                       *)
(*                heap.(i) <- Some i;                                                           *)
(*                raise (Found i)                                                               *)
(*            | _ -> ()                                                                       *)
(*        done;                                                                               *)
(*        failwith "create"                                                                   *)
(*      with Found i -> i                                                                     *)
(*    let free heap i = heap.(i) <- None                                                      *)
(*    let address var = var                                                                   *)
(*                                                                                            *)
(*    let add var value ((i,pa) as state) =                                                   *)
(*      let addr = address var in                                                             *)
(*      Seq [fst (moveTo state addr);                                                         *)
(*      Seq (if value=0 then [] else                                                          *)
(*        if value>0 then replicate value Plus else                                           *)
(*          replicate (-value) Minus)],(addr,set pa addr (value+get pa addr))                 *)
(*    end                                                                                     *)
(*    let print_char state c =                                                                *)
(*      let n = int_of_char c in                                                              *)
(*      Seq (replicate n Plus @ [Output] @ replicate n Minus)                                 *)
(*    let print_string state s =                                                              *)
(*      foldl (fun s e -> Seq [s;e]) (Seq []) @$ map (print_char state) @$ ExtString.to_list s*)